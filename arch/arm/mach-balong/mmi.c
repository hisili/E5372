
/**********************************************************
  Copyright (C) 2012, Huawei Tech. Co., Ltd.    
  File name: mmi.c
  AUthor: gongashi Version: v1.0  date 2012.01.08
  Description: MMI工位
  Funtion List:
    1\
  History:
    1. date: 2012.01.06
       Author: gongashi
       Modification: create the file
    
 
**********************************************************/
/**********************问题单修改记录*****************************************************
日    期              修改人                     问题单号                   修改内容
***************************************************************************************/
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/delay.h>
#include <linux/irq.h>
#include <linux/sched.h>
#include <linux/kthread.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/syscalls.h>
#include <../include/asm/uaccess.h>
#include "BSP.h"
#include "mmi.h"
#include <generated/FeatureConfig.h>

#if ( FEATURE_E5 == FEATURE_ON ) && (defined(VERSION_V3R2))
#include "../../../drivers/staging/balong_oled_emi/balong_oled_drv.h"
#include "../../../drivers/led_drv/balong_led_drv.h"
#endif

#include "../../../drivers/mntn/include/omDrv.h"
#include "../../../drivers/mntn/excDrv.h"    
#include "../../../drivers/staging/balong_tft_emi/balong_tft_drv.h"
#include "../../../drivers/led_drv/balong_led_drv.h"
#include "../../../include/linux/BSP_CHGC_DRV.h"
#include "../../../include/linux/bsp_pmu_drv.h"

#if ( FEATURE_MMI_TEST == FEATURE_ON )

extern BSP_U32 NVM_Read(BSP_U16 usID,BSP_VOID *pItem,BSP_U32 ulLength);
extern BSP_U32 NVM_Write(BSP_U16 usID,BSP_VOID *pItem,BSP_U32 ulLength);
extern BSP_S32 sd_mmc_get_status(BSP_VOID);
extern BSP_VOID tftLight(BSP_VOID);
void mmi_write_nv_f(void);
    
#define OLED_IMAGE_SIZE 128*64
#define ERR_MSP_NO_INITILIZATION 3 //NV函数没有初始化
#define MMI_MOUNT_COUNT_MAX 3

#if ((defined(CHIP_BB_6920ES) || defined (CHIP_BB_6920CS)) && (FEATURE_E5 == FEATURE_ON))
extern uint8_t is_current_firmware_factory;
#endif /*(defined(CHIP_BB_6920...*/

/********************************************************
变量定义区:
*********************************************************/

#if ((defined (CHIP_BB_6920ES) || defined (CHIP_BB_6920CS))\
&& (defined (BOARD_SFT)||defined (BOARD_ASIC)||defined (BOARD_ASIC_BIGPACK)))

#if defined(FEATURE_LCD_BOTTOM)
const unsigned char  g_AllIconPic[1024]=
{//全屏效果图(128*64)
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X01,0XE0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X38,0X00,0X00,0X00,0X00,0X06,0XB0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X28,0X00,0X00,0X00,0X00,0X0C,0X98,0X03,0XFF,0XC0,0X1F,0XFF,0XC0,0X00,
	0X00,0X00,0X38,0X03,0XFF,0XFF,0X00,0X1F,0XFC,0X04,0XFF,0XA0,0X18,0X00,0XC0,0X00,
	0X00,0X01,0X28,0X03,0XFB,0X05,0X00,0X24,0X92,0X06,0X7E,0X20,0X16,0XDB,0X40,0X00,
	0X00,0X01,0X28,0X02,0XAF,0X71,0X38,0X24,0X92,0X07,0X3C,0XE0,0X76,0XDB,0X40,0X00,
	0X00,0X05,0X00,0X02,0XAB,0X45,0X28,0X3F,0XFE,0X07,0X99,0XE0,0X76,0XDB,0X40,0X00,
	0X00,0X15,0X39,0XC2,0X4B,0X75,0X08,0X24,0X92,0X07,0X00,0XE0,0X76,0XDB,0X40,0X00,
	0X00,0X15,0X0A,0X03,0X5B,0X45,0X10,0X24,0X92,0X06,0X7E,0X60,0X76,0XDB,0X40,0X00,
	0X00,0X55,0X1A,0XC3,0X5B,0X45,0X38,0X3F,0XFC,0X04,0XFF,0X20,0X16,0XDB,0X40,0X00,
	0X00,0X55,0X0A,0X43,0XFF,0XFF,0X00,0X14,0X94,0X05,0XFF,0X80,0X18,0X00,0XC0,0X00,
	0X00,0X55,0X39,0XC0,0X00,0X00,0X00,0X0E,0XB8,0X03,0XFF,0XC0,0X1F,0XFF,0XC0,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X03,0XE0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X1E,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X33,0X00,0X00,0X00,0X00,0X40,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X61,0X80,0X00,0X00,0X00,0XC0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X61,0X9B,0X0F,0X1E,0X79,0XE7,0X8F,0X06,0XC3,0XC6,0XEC,0X3C,0X00,0X00,
	0X00,0X00,0X61,0X9D,0X99,0X98,0X8C,0XCC,0XCC,0X07,0X64,0X67,0X76,0X66,0X00,0X00,
	0X00,0X00,0X61,0X99,0X99,0X98,0X3C,0XCC,0XCC,0X06,0X61,0XE6,0X66,0X66,0X00,0X00,
	0X00,0X00,0X61,0X99,0X9F,0X98,0X6C,0XCC,0XCC,0X06,0X63,0X66,0X66,0X7E,0X00,0X00,
	0X00,0X00,0X61,0X99,0X98,0X18,0XCC,0XCC,0XCC,0X06,0X66,0X66,0X66,0X60,0X00,0X00,
	0X00,0X00,0X33,0X1D,0X99,0X98,0XCC,0XCC,0XCC,0X06,0X66,0X66,0X66,0X66,0X00,0X00,
	0X00,0X00,0X1E,0X1B,0X0F,0X18,0X7C,0X67,0X8C,0X06,0X63,0XE6,0X66,0X3C,0X00,0X00,
	0X00,0X00,0X00,0X18,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X18,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X18,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X1C,0X71,0XC4,0X13,0XC2,0X23,0X90,0X3C,0XE0,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X22,0X8A,0X26,0X32,0X22,0X64,0X50,0X21,0X10,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X22,0X0A,0X26,0X32,0X24,0XA4,0X5E,0X78,0X13,0XB0,0X00,0X00,0X00,
	0X00,0X00,0X00,0X1E,0X12,0X25,0X53,0XC4,0X24,0X51,0X44,0X22,0X48,0X00,0X00,0X00,
	0X00,0X00,0X00,0X02,0X22,0X25,0X52,0X24,0X24,0X51,0X04,0X42,0X48,0X00,0X00,0X00,
	0X00,0X00,0X00,0X22,0X42,0X24,0X92,0X28,0X24,0X51,0X44,0X82,0X48,0X00,0X00,0X00,
	0X00,0X00,0X00,0X1C,0XF9,0XC4,0X93,0XC8,0X23,0X91,0X39,0XF2,0X48,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,

};
#else
const unsigned char  g_AllIconPic[2048]=
{//全屏效果图(128*128)
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X7C,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X1C,0X00,0X00,0X00,0X00,0X01,0XD7,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X94,0X00,0X00,0X00,0X00,0X03,0X93,0X80,0XFF,0XF0,0X00,0XFF,0XFE,0X00,
	0X00,0X00,0X9C,0X00,0X7F,0XFF,0XE0,0X03,0XFF,0X81,0X3F,0XC8,0X00,0XC0,0X06,0X00,
	0X00,0X02,0X94,0X00,0X7F,0X60,0XA0,0X06,0X92,0XC1,0X9F,0X98,0X00,0XB6,0XDA,0X00,
	0X00,0X02,0X94,0X00,0X55,0XEE,0X27,0X04,0X92,0X41,0XCF,0X38,0X03,0XB6,0XDA,0X00,
	0X00,0X0A,0X80,0X00,0X55,0X68,0XA4,0X07,0XFF,0XC1,0XE6,0X7B,0XC3,0XB6,0XDA,0X00,
	0X00,0X2A,0X9C,0XE0,0X49,0X6E,0XA7,0X04,0X92,0X41,0XC0,0X3E,0X63,0XB6,0XDA,0X00,
	0X00,0X2A,0X85,0X00,0X6B,0X68,0XA1,0X06,0X92,0XC1,0X9F,0X9E,0X73,0XB6,0XDA,0X00,
	0X00,0XAA,0X8D,0X60,0X6B,0X68,0XA7,0X03,0XFF,0X81,0X3F,0XCD,0X70,0XB6,0XDA,0X00,
	0X00,0XAA,0X85,0X20,0X7F,0XFF,0XE0,0X03,0X93,0X81,0X7F,0XEC,0X30,0XC0,0X06,0X00,
	0X00,0XAA,0X9C,0XE0,0X00,0X00,0X00,0X01,0XD7,0X00,0XFF,0XF7,0X60,0XFF,0XFE,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X7C,0X00,0X00,0X03,0XC0,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X1F,0X80,0X00,0X00,0X00,0X00,0X00,0X10,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X7F,0XE0,0X00,0X00,0X00,0X00,0X00,0X30,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0XFF,0XF0,0X00,0X00,0X00,0X00,0X00,0X70,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0XF0,0XF0,0X00,0X00,0X00,0X00,0X00,0X70,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X01,0XE0,0X79,0XDE,0X07,0XC3,0XB8,0XF8,0XFC,0X1E,0X0E,0XE0,0X00,0X00,
	0X00,0X00,0X01,0XC0,0X39,0XFF,0X0F,0XE3,0XF9,0XFC,0XFC,0X7F,0X8F,0XE0,0X00,0X00,
	0X00,0X00,0X01,0XC0,0X39,0XE7,0X1C,0X73,0XC3,0X0E,0X70,0X73,0X8F,0X00,0X00,0X00,
	0X00,0X00,0X01,0XC0,0X39,0XC3,0X9C,0X73,0X80,0X0E,0X70,0XE1,0XCE,0X00,0X00,0X00,
	0X00,0X00,0X01,0XC0,0X39,0XC3,0X9F,0XF3,0X80,0X7E,0X70,0XE1,0XCE,0X00,0X00,0X00,
	0X00,0X00,0X01,0XC0,0X39,0XC3,0X9F,0XF3,0X81,0XFE,0X70,0XE1,0XCE,0X00,0X00,0X00,
	0X00,0X00,0X01,0XE0,0X79,0XC3,0X9C,0X03,0X83,0XCE,0X70,0XE1,0XCE,0X00,0X00,0X00,
	0X00,0X00,0X00,0XF0,0XF1,0XC3,0X9C,0X03,0X83,0X8E,0X70,0XE1,0XCE,0X00,0X00,0X00,
	0X00,0X00,0X00,0XFF,0XF1,0XE7,0X1E,0X73,0X83,0X9E,0X70,0X73,0X8E,0X00,0X00,0X00,
	0X00,0X00,0X00,0X7F,0XE1,0XFF,0X0F,0XE3,0X83,0XFE,0X7C,0X7F,0X8E,0X00,0X00,0X00,
	0X00,0X00,0X00,0X1F,0X81,0XDE,0X07,0XC3,0X81,0XE7,0X3C,0X1E,0X0E,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X01,0XC0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X01,0XC0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X01,0XC0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X01,0XC0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X07,0X87,0X87,0X88,0X09,0XF8,0X02,0X07,0XC3,0XE0,0X00,0X00,0X00,
	0X00,0X00,0X00,0X08,0X48,0X48,0X4C,0X19,0X04,0X02,0X04,0X04,0X10,0X00,0X00,0X00,
	0X00,0X00,0X00,0X08,0X48,0X48,0X4C,0X19,0X04,0X04,0X08,0X08,0X08,0X00,0X00,0X00,
	0X00,0X00,0X00,0X08,0X40,0X48,0X4A,0X29,0X04,0X04,0X0F,0X88,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X08,0XC0,0X48,0X4A,0X29,0XF8,0X04,0X08,0X48,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X07,0X40,0X88,0X49,0X49,0X04,0X08,0X00,0X48,0X78,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X41,0X08,0X49,0X49,0X04,0X08,0X00,0X48,0X08,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X42,0X08,0X49,0X49,0X04,0X08,0X08,0X48,0X08,0X00,0X00,0X00,
	0X00,0X00,0X00,0X08,0X84,0X08,0X48,0X89,0X04,0X10,0X08,0X84,0X10,0X00,0X00,0X00,
	0X00,0X00,0X00,0X07,0X0F,0XC7,0X88,0X89,0XF8,0X10,0X07,0X83,0XE0,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
	0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,

};
#endif

#endif /*((defined (CHIP_BB_6920ES)...*/

#if ( FEATURE_E5 == FEATURE_ON ) && (defined(VERSION_V3R2))
/********************************************************
变量定义区:
*********************************************************/
const unsigned char  g_AllIconPic[OLED_IMAGE_SIZE]=
{
/*--  调入了一幅图像：--*/
/*--  宽度x高度=128x64  --*/
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xC0,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xD9,0xBF,0xCF,0xFF,0xFF,0xFF,0x80,0x01,0xF8,0x37,0xFF,0xFF,0xFF,0xFF,0x00,0x01,
0xE9,0x7F,0xCF,0xFF,0xFF,0xFF,0x00,0x7E,0xF3,0x3B,0xFF,0xFF,0xFF,0xFF,0x7F,0xFD,
0xF0,0xFF,0xCF,0xFF,0xFF,0xFF,0x45,0x4A,0xE7,0x9D,0xFF,0xFF,0xFF,0xFC,0x49,0x25,
0xF9,0xFC,0xCF,0xFF,0xFF,0xFF,0x54,0x5E,0xEB,0x5D,0xFF,0xFF,0xFF,0xFD,0xC9,0x25,
0xF9,0xFC,0xCF,0xFF,0xFF,0xFF,0x55,0x5A,0xE7,0xFD,0xFF,0xFF,0xFF,0xFD,0xC9,0x25,
0xF9,0xCC,0xCF,0xFF,0xFF,0xFF,0x55,0x4A,0xEF,0xF5,0xFF,0xFF,0xFF,0xFD,0xC9,0x25,
0xF9,0xCC,0xCF,0xFF,0xFF,0xFF,0x55,0x5A,0xEF,0xE5,0xFF,0xFF,0xFF,0xFD,0xC9,0x25,
0xF9,0xCC,0xCF,0xFF,0xFF,0xFF,0x29,0x5A,0xEF,0x83,0xFF,0xFF,0xFF,0xFC,0x49,0x25,
0xF9,0xCC,0xCF,0xFF,0xFF,0xFF,0x00,0x7E,0xF7,0xC3,0xFF,0xFF,0xFF,0xFF,0x7F,0xFD,
0xF9,0xCC,0xCF,0xFF,0xFF,0xFF,0x80,0x01,0xFB,0xC7,0xFF,0xFF,0xFF,0xFF,0x00,0x01,
0xF9,0xCC,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xF9,0xCC,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x00,0xE7,0xE7,0xE0,0xFC,0x07,0xCF,0x3F,0xC0,0x1F,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE7,0xE7,0x8E,0x3C,0xF3,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE3,0xC7,0x9F,0x3C,0xF9,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE3,0xC7,0x3F,0x9C,0xF9,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE1,0x87,0x3F,0x9C,0xF3,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x01,0xE1,0x87,0x3F,0x9C,0x07,0xCF,0x3F,0xC0,0x3F,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE4,0x27,0x3F,0x9C,0xF3,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE4,0x27,0x3F,0x9C,0xF9,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE6,0x67,0x3F,0x9C,0xF9,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE6,0x67,0x9F,0x3C,0xF9,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x7F,0xE7,0xE7,0x8E,0x3C,0xF3,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0x00,0xE7,0xE7,0xE0,0xFC,0x07,0xCF,0x00,0xC0,0x1F,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x07,0xFF,0xFF,
0x9F,0xF9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFB,0xFE,0x7F,
0x8F,0xF1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x3B,0xFE,0x7F,
0x8F,0xF1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x1B,0xFE,0x7F,
0x87,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0xCB,0xFE,0x7F,
0x87,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0xCB,0xFE,0x7F,
0x93,0xC9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0xCB,0xFE,0x7F,
0x93,0xC9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x1B,0xFE,0x7F,
0x99,0x99,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x3B,0xFE,0x7F,
0x99,0x99,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x99,0xFB,0xFE,0x7F,
0x9C,0x39,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x9C,0x7B,0xFE,0x7F,
0x9C,0x39,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x9E,0x0B,0xFF,0xFF,
0x9E,0x79,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0x8B,0xFF,0xFF,
};
#endif
const unsigned char  g_HandPic[OLED_IMAGE_SIZE]=
{
/*--  宽度x高度=128x64  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x07,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x07,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x07,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x70,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

#if (FEATURE_OTG == FEATURE_ON)
/*just for no  sd  card mmi test*/
BSP_U32 no_card_debug_mode = 0;
BSP_U32 no_AF10_debug_mode = 0;
#endif

/* 5分钟mmi测试没有完成，退出mmi测试模式 */
unsigned int mmi_test_mode  = false;

/* 是否需要挂载TF卡文件系统 */
unsigned int g_need_mount_flag = true;

/*挂载文件节点名*/
char g_mount_name[32] ={0};

/* 屏幕状态:全灭,全亮,显示所有图片 */
OLED_DIS_STA mmi_dis_sta = OLED_DIS_BLACK;
KEY_TEST_EVENT mmi_test_event;

/*SIM卡检测用变量*/
BSP_U32 g_u32MmiUsimcStatus =0;
BSP_U32 SIM_MSG1 =0;// 核间通信用
BSP_U32 SIM_MSG2 =0;// 核间通信用
BSP_U32 SIM_MSG3 =0;// 核间通信用

#if((FEATURE_ON == FEATURE_E5371_MMI))
/* 前壳温度检测用变量*/
static BSP_U32 g_u32MmiadccStatus = 0;
static BSP_S32 ADC_MSG1 = 0;  /* 核间通信，命名规则与海思基线保持一致 */
#endif


tft_write_data mmi_image_dis = {
    .x_start = 0,
    .y_start = 0,
    .x_offset = 128,
    .y_offset = 64,
    .image = g_AllIconPic,
    .size = sizeof( g_AllIconPic )
};

static LED_IOCTL_ARG mmi_pst_arg = {0};
/********************************************************
函数定义区:
*********************************************************/
#if (FEATURE_OTG == FEATURE_ON)
/*just for no  sd  card mmi test*/
void st_no_card_debug(void)
{
    no_card_debug_mode = 0x55;
}
void st_no_AF10_debug(void)
{
    no_AF10_debug_mode = 1;
}

#endif
/******************************************************
  Function:  mmi_file_open
  Description: try to open Huawei_e5_mmi_test.cfg 
  Input:  none
  output:  none 
  author: g175336
  date: 2012.01.06
******************************************************/
int mmi_file_open( const char * dir, int flags )
{
    long fd;
    mm_segment_t sd_fs = get_fs();
    if ( NULL == dir )
    {
        return -1;
    }
	
    printk("sd vfat process test!\n");
    set_fs(KERNEL_DS);
//    fd = sys_open("/mnt/sdcard0/Huawei_e5_mmi_test.cfg", O_RDWR | O_NDELAY, 0);
    fd = sys_open(dir, flags, 0);
    if (fd >= 0)
    {
        printk("sd sys open success!\n");
        sys_close(fd);
    }
    set_fs(sd_fs);
    return fd;
}
/******************************************************
  Function:  mmi_mount_sd
  Description: mount sd card file system
  Input:  none
  output:  true or false 
  author: g175336
  date: 2012.03.24
******************************************************/
int mmi_mount_sd(void)
{
    int mount_cnt = 0;

    for ( mount_cnt = 0; mount_cnt < MMI_MOUNT_COUNT_MAX; mount_cnt++ )
    {
        sprintf( g_mount_name, MMI_TEST_SD_DIR_P1, mount_cnt );
		printk( KERN_DEBUG "mmi mount node is %s!!!\r\n", g_mount_name );

        /*挂载SD卡文件系统:/dev/block/mmcblk0p%d*/
        if ( 0 == do_mount( g_mount_name, "/mnt/sdcard0", "vfat", MS_SILENT, NULL ) )
        {                            
            break;
        }
        printk( KERN_INFO "vfat: error mounting %s!!! \r\n", g_mount_name );

        sprintf( g_mount_name, MMI_TEST_SD_DIR, mount_cnt );
		printk( KERN_DEBUG "mmi mount node is %s!!!\r\n", g_mount_name );
	 
        /*挂载SD卡文件系统:/dev/block/mmcblk%d*/
        if ( 0 == do_mount( g_mount_name, "/mnt/sdcard0", "vfat", MS_SILENT, NULL ) )
        {
            break;
        }
        printk( KERN_INFO "vfat: error mounting %s!!! \r\n", g_mount_name );

    }

	if ( MMI_MOUNT_COUNT_MAX <= mount_cnt )
    {
        return false;
    }
	else
    {
        return true;
    }

}

#if((FEATURE_ON == FEATURE_E5371_MMI))
/*******************************************************************************
  Function:    mmi_adc_ifc_send()
  Description: 双核消息发送函数
  Input:    Msg_Type  :消息类型
            u32_msg   :消息内容
  Output:
  NOTE:
  Return:   BSP_OK    :消息发送成功
            BSP_ERROR :消息发送失败
  History:
      1.  戴志成     2012.10.09  新版做成
*******************************************************************************/
BSP_S32 mmi_adc_ifc_send(BSP_U32 Msg_Type, BSP_U32 u32_msg)
{
    BSP_U32 u32send_ret = 0;
    BSP_U32 msg[MSG_LEN];

    msg[0] = IFC_MODULE_BSP;
    msg[1] = IFCP_FUNC_MMI_ADC_STATUS_GET;
    msg[MSG_SECOND] = Msg_Type;
    msg[MSG_THIRD] = u32_msg;

    u32send_ret = BSP_IFC_Send((BSP_VOID*)msg, sizeof(msg));

    printk(KERN_ERR "mmi_adc_ifc_send type:%d,u32_msg:%d,ret=0x%x\n",msg[0],msg[1],u32send_ret);
    if(BSP_OK != u32send_ret)
    {
        return BSP_ERROR;
    }

    return BSP_OK;
}

/*******************************************************************************
  Function:    mmi_adc_ifc_recv()
  Description: 双核消息发送函数
  Input:    pMsgBody  :消息
            u32Len    :消息长度
  Output:
  NOTE:
  Return:   BSP_OK    :消息接受成功
            BSP_ERROR :消息接受失败
  History:
      1.  戴志成     2012.10.09  新版做成
*******************************************************************************/
BSP_U32 mmi_adc_ifc_recv(BSP_VOID *pMsgBody, BSP_U32 u32Len)
{
    BSP_S32 u32MsgType = 0;

    /*解析C核传来的消息数据*/
    u32MsgType = (BSP_S32)(*(volatile BSP_U32 *)((BSP_U32)pMsgBody));
    ADC_MSG1 = (BSP_S32)(*(volatile BSP_U32 *)((BSP_U32)pMsgBody + sizeof(BSP_U32)));

    g_u32MmiadccStatus |= ( 1 << u32MsgType);

    printk(KERN_ERR "mmi_adc_ifc_recv:BSP_OK,GetInterface:%d,MSG1=%d,MSG2=%d,MSG3=%d,g_u32MmiUsimcStatus=%d\n",
        u32MsgType,ADC_MSG1,0,0,g_u32MmiadccStatus);
    return BSP_OK;
}

/*******************************************************************************
  Function:    mmi_adc_ifc_init()
  Description: 双核消息初始化函数，进行双核通信函数的注册
  Input:    void
  Output:
  NOTE:
  Return:   BSP_OK    :函数注册成功
            BSP_ERROR :函数注册失败
  History:
      1.  戴志成     2012.10.09  新版做成
*******************************************************************************/
BSP_S32 mmi_adc_ifc_init()
{
    BSP_U32 u32Ret = 0;

    u32Ret = BSP_IFCP_RegFunc(IFCP_FUNC_MMI_ADC_STATUS_SET, (BSP_IFCP_REG_FUNC)mmi_adc_ifc_recv);

    if(BSP_OK != u32Ret)
    {
        printk(KERN_ERR "%s: BSP_IFCP_RegFunc ERROR!!!\r\n", __func__);
        return BSP_ERROR;
    }

    return BSP_OK;
}

/*******************************************************************************
  Function:    mmi_adc_ifc_wait()
  Description: 等待接受双核消息
  Input:    Msg_Type  :消息类型
  Output:
  NOTE:
  Return:   BSP_OK    :规定时间内等待到双核消息的返回(当前超时时间2s)
            BSP_ERROR :等待超时
  History:
      1.  戴志成     2012.10.09  新版做成
*******************************************************************************/
BSP_S32 mmi_adc_ifc_wait(BSP_U32 MsgType)
{
    BSP_U32 u32module = 1 << (BSP_U32)MsgType;
    BSP_U32 u32flag = 1;
    BSP_U32 i = 0;

    for(i = 0; i < BSP_MMI_ADC_TIMEOUT; i++)
    {
        if(g_u32MmiadccStatus & u32module)
        {
            printk(KERN_ERR "mmi_adc_ifc_wait:BSP_OK \n");
            break;
        }

        if(u32flag)
        {
            printk(KERN_ERR "###### module %d waiting", MsgType);
            u32flag = 0;
        }

        msleep(SLEEP_TIME);
    }

    if(BSP_MMI_ADC_TIMEOUT == i)
    {
        g_u32MmiadccStatus = (g_u32MmiadccStatus & (u32module));
        printk(KERN_ERR "mmi_adc_ifc_wait:time out \n");
        return BSP_ERROR;
    }
    else
    {
        g_u32MmiadccStatus = (g_u32MmiadccStatus & (u32module));
        return BSP_OK;
    }

}

/*******************************************************************************
  Function:    mmi_adc_status_query()
  Description: 前壳温度获取函数
  Input:    void
  Output:
  NOTE:
  Return:   BSP_OK    :从C核获取前壳温度OK
            BSP_ERROR :从C核获取前壳温度fail
  History:
      1.  戴志成     2012.10.09  新版做成
*******************************************************************************/
BSP_S32 mmi_adc_status_query(void)
{
    BSP_S32 s32ret_send = -1;
    BSP_S32 s32ret_rece = -1;

    /*向C核发送查询消息*/
    s32ret_send = mmi_adc_ifc_send(MMI_ADC_STATUS_QUERY, 0);

    if(BSP_OK == s32ret_send)
    {
        /*等待C核反馈*/
        s32ret_rece = mmi_adc_ifc_wait(MMI_ADC_STATUS_QUERY);

        if(BSP_OK == s32ret_rece)
        {
            return ADC_MSG1;
        }
        else
        {
            return BSP_ERROR;
        }
    }
    else
    {
        return BSP_ERROR;
    }
}

/*******************************************************************************
  Function:    mmi_adc_status()
  Description: 获取前壳温度是否正常
  Input:    VOS_VOID
  Output:
  NOTE:
  Return:   VOS_VOID
  History:
      1.  戴志成     2003.12.11  新版做成
*******************************************************************************/
MMI_ADC_STA mmi_adc_status(void)
{
    BSP_S32 adc_sta = 0;

    printk(KERN_INFO "%s: adc temp test enter!!!\r\n", __func__);
    adc_sta = mmi_adc_status_query();
    if(0 == adc_sta)
    {
        printk(KERN_INFO "%s: ADC temp OK !!!\r\n", __func__);
        return MMI_ADC_TEMP_OK;
    }
    else
    {
        printk(KERN_ERR "%s: ADC temp fail!!!\r\n", __func__);
        return MMI_ADC_TEMP_FAIL;
    }
}

#endif /* #if((FEATURE_ON == FEATURE_E5371_MMI)) */

BSP_S32 mmi_sci_ifc_send(BSP_U32 Msg_Type, BSP_U32 u32_msg)
{
    BSP_U32 u32send_ret = 0;
	BSP_U32 msg[4];

	msg[0] = IFC_MODULE_BSP;
	msg[1] = IFCP_FUNC_MMI_USIM_STATUS_GET;
	msg[2] = Msg_Type;
	msg[3] = u32_msg;

	u32send_ret = BSP_IFC_Send((BSP_VOID*)msg, sizeof(msg));
	
	printk(KERN_ERR "mmi_sci_ifc_send type:%d,u32_msg:%d,ret=0x%x\n",msg[2],msg[3],u32send_ret);
	if(BSP_OK != u32send_ret)
	{
	    return BSP_ERROR;
	}

	return BSP_OK;
}


BSP_U32 mmi_sci_ifc_recv(BSP_VOID *pMsgBody, BSP_U32 u32Len)
{
    BSP_S32 u32MsgType = 0;

    /*解析C核传来的消息数据*/
	u32MsgType = (BSP_S32)(*(volatile BSP_U32 *)((BSP_U32)pMsgBody));
	SIM_MSG1 = (BSP_S32)(*(volatile BSP_U32 *)((BSP_U32)pMsgBody + sizeof(BSP_U32)));
	SIM_MSG2 = (BSP_S32)(*(volatile BSP_U32 *)((BSP_U32)pMsgBody + 2*sizeof(BSP_U32)));
	SIM_MSG3 = (BSP_S32)(*(volatile BSP_U32 *)((BSP_U32)pMsgBody + 3*sizeof(BSP_U32)));

	g_u32MmiUsimcStatus |= ( 1<< u32MsgType);

	printk(KERN_ERR "BSP_Mmi_Usim_GetInterface:BSP_OK,GetInterface:%d,MSG1=%d,MSG2=%d,MSG3=%d,g_u32MmiUsimcStatus=%d\n",
		u32MsgType,SIM_MSG1,SIM_MSG2,SIM_MSG3,g_u32MmiUsimcStatus);
	return BSP_OK;
}
BSP_S32 mmi_sci_ifc_init()
{
    BSP_U32 u32Ret = 0;

	u32Ret = BSP_IFCP_RegFunc(IFCP_FUNC_MMI_USIM_STATUS_SET, (BSP_IFCP_REG_FUNC)mmi_sci_ifc_recv);

	if(BSP_OK != u32Ret)
	{
		printk(KERN_ERR "%s: BSP_IFCP_RegFunc ERROR!!!\r\n", __func__);
	    return BSP_ERROR;
	}
	
	return BSP_OK;
}

/******************************************************
  Function:  BSP_MMI_USIM_Wait
  Description: 等待M核返回消息
  Input:  BSP_U32 : MsgType
  output: 
  author: n00203913
  date: 2012.06.06
******************************************************/
BSP_S32 mmi_sci_ifc_wait(BSP_U32 MsgType)
{
    BSP_U32 u32module = 1<<(BSP_U32)MsgType;
	BSP_U32 u32flag =1;
	BSP_U32 i = 0;

	for(i=0; i<BSP_MMI_USIM_TIMEOUT; i++)
	{
	    if(g_u32MmiUsimcStatus & u32module)
	    {
	        printk(KERN_ERR "mmi_sci_ifc_wait:BSP_OK \n");
			break;
	    }

		if(u32flag)
		{
		    printk(KERN_ERR "###### module %d waiting", MsgType);
			u32flag =0;
		}

		msleep(20);
	}

	if(BSP_MMI_USIM_TIMEOUT == i)
	{
	    g_u32MmiUsimcStatus = (g_u32MmiUsimcStatus & (u32module));
		printk(KERN_ERR "mmi_sci_ifc_wait:time out \n");
		return BSP_ERROR;
	}
	else
	{
	    g_u32MmiUsimcStatus = (g_u32MmiUsimcStatus & (u32module));
		return BSP_OK;
	}
	
}


BSP_S32 mmi_usim_exist_query(void)
{
    BSP_S32 s32ret_send =-1;
	BSP_S32 s32ret_rece =-1;

    /*向C核发送查询消息*/
	s32ret_send = mmi_sci_ifc_send(MMI_USIM_STATUS_QUERY, 0);

	if(BSP_OK == s32ret_send)
	{
	    /*等待C核反馈*/
	    s32ret_rece = mmi_sci_ifc_wait(MMI_USIM_STATUS_QUERY);

		if(BSP_OK == s32ret_rece && BSP_OK == SIM_MSG2)
		{
		    return SIM_MSG1;
		}
		else
		{
		    return BSP_ERROR;
		}
	}
	else
	{
	    return BSP_ERROR;
	}
}

/******************************************************
  Function:  mmi_usim_exist
  Description: whether SIM card exist or not
  Input:  none
  output: 
    MMI_USIM_EXIST    : USIM卡在位:1
    MMI_USIM_NOT_EXIST: USIM卡不在位:0
  
  author: n00203913
  date: 2012.06.06
******************************************************/
MMI_USIM_STA mmi_usim_exist(void)
{
	BSP_S32 CardSta = 0;

	printk(KERN_INFO "%s: USIM card test enter!!!\r\n", __func__);
	CardSta = mmi_usim_exist_query();
	if(CARD_OK == CardSta)
	{
	    printk(KERN_INFO "%s: USIM card exist!!!\r\n", __func__);
		return MMI_USIM_EXIST;
	}
	else
	{
	    printk(KERN_ERR "%s: USIM card not exist!!!\r\n", __func__);
	    return MMI_USIM_NOT_EXIST;
	}
}

/******************************************************
  Function:  mmi_file_exist
  Description: whether Huawei_e5_mmi_test.cfg exist or not
  Input:  none
  output: 
    MMI_SD_NOT_INIT: SD卡还未初始化完成,需继续等待...
    MMI_FILE_NOT_EXIST: MMI测试文件不存在
    MMI_FILE_OK: MMI测试文件存在,可进入MMI测试模式
  
  author: g175336
  date: 2012.01.06
******************************************************/
MMI_FILE_STA mmi_file_exist(void)
{
    long ret = 0;

    printk( KERN_INFO "%s: enter!!! \r\n", __func__ );
	
/* BEIGN ,Added by xuchao,2012/2/21 */
#if ( FEATURE_E5 == FEATURE_ON ) && (defined(VERSION_V3R2))
	if (sd_get_status())		
    {
        g_need_mount_flag = true;
        return MMI_SD_NOT_INIT;
    }
#endif

#if ((defined (CHIP_BB_6920ES) || defined (CHIP_BB_6920CS))\
&& (defined (BOARD_ASIC)||defined (BOARD_ASIC_BIGPACK)))
    
	if( 0 != sd_mmc_get_status())
	{
		printk( KERN_INFO "%s: sd_mmc_get_status function returned error!!! \r\n", __func__ );
        g_need_mount_flag = true;
        return MMI_SD_NOT_INIT;
	}

#endif /*((defined (CHIP_BB_6920ES)...*/

/* END   ,Added by xuchao,2012/2/21 */

	if ( false == g_need_mount_flag )
	{
        return MMI_FILE_NOT_EXIST;
	}
	
    if ( mmi_file_open( "/mnt/sdcard0", O_DIRECTORY ) < 0 )
    {
        /*在/mnt目录下创建sdcard0目录*/
        ret = sys_mkdir( "/mnt/sdcard0", 0777 ); 
        if (ret)
        {
            printk( KERN_INFO "%s: error mkdir!!!, ret=%d \r\n", __func__, ret );
            return MMI_FILE_NOT_EXIST;		
        }
    }
	
    printk(KERN_INFO "!!!sdcard0 exist!!!\r\n");
	
	if ( true == g_need_mount_flag )
    {
        if ( false == mmi_mount_sd() )
        {
            printk( KERN_INFO " %s: mount sd filesystem error!!! ", __func__ );
        }
    }

    /*查看SD卡内是否有"Huawei_e5_mmi_test.cfg"文件*/
    if ( mmi_file_open( "/mnt/sdcard0/Huawei_e5_mmi_test.cfg", O_RDWR | O_NDELAY ) < 0 )
    {   
        ret = sys_umount( "/mnt/sdcard0", 0 );
		if ( 0 != ret )
        {
            //for lint
        }
        g_need_mount_flag = FALSE;
        printk(KERN_INFO "Huawei_e5_mmi_test.cfg is NOT found!!! \r\n");
        return MMI_FILE_NOT_EXIST;			
    }
    else //MMI文件存在
    {
        /*防止后面超时退出，又要重新挂载*/
        ret = sys_umount( "/mnt/sdcard0", 0 );
		if ( 0 != ret )
        {
            //for lint
        }
		g_need_mount_flag = true;
        printk( KERN_INFO "Success: Enter MMI test mode, ret = %d \r\n", ret );
        return MMI_FILE_OK;			
    }
}

/******************************************************
  Function:  enter_mmi_test
  Description:  ok, enter_mmi_test
  Input:  none
  output:  none 
  author: g175336
  date: 2012.01.06
******************************************************/
void enter_mmi_test(void)
{
    int lint_ret; //for lint
    unsigned char str_pt[] = MMI_TEST_BEGIN;
    printk( KERN_INFO " %s: mmi start!!!\r\n ", __func__ );	

    mmi_test_mode = true;
    mmi_test_event.timeout = msecs_to_jiffies( MMI_TEST_TIMEOUT ) + jiffies;

    /*首先关闭led灯并清空屏幕*/
#if (FEATURE_BREATH_LIGHT == FEATURE_ON)
    lint_ret = balong_breath_led_ioctl( 0, 0, (unsigned int)BREATH_LED_ID_POWER, 0 );
#endif

	lint_ret = ( int )balong_tft_ioctl (NULL, (unsigned int)OLED_ALL_BLACK, 0);

/* BEIGN ,Added by xuchao,2012/2/24 */
#if ( FEATURE_E5 == FEATURE_ON ) && (defined(VERSION_V3R2))
	/* 在屏幕上显示"MMI TEST", 后面会改成手型图标*/
	tftStringDisplay( 0, 0, str_pt );
#endif

#if ((defined (CHIP_BB_6920ES) || defined (CHIP_BB_6920CS))\
	&& (defined (BOARD_ASIC)||defined (BOARD_ASIC_BIGPACK)))
	/*在屏幕上显示"MMI TEST"*/
    tftLight();
	//tftRefreshByBit(0,32,128,64,g_HandPic);
	tftStringDisplay(32,58,(UINT8 *)MMI_TEST_BEGIN);
#endif /*((defined (CHIP_BB_6920ES)...*/
/* END	 ,Added by xuchao,2012/2/24 */

    if ( lint_ret )
    {
        //for lint
    }
}

/******************************************************
  Function:  mmi_dis_roll
  Description:  mmi_dis_roll
  Input:  none
  output:  none
  author: g175336
  date: 2012.01.06
******************************************************/
void mmi_dis_roll( OLED_DIS_STA oled_dis_sta )
{
    int pr_ret = 0;    //for lint
    switch ( (oled_dis_sta) % OLED_DIS_MAX )
    {
        case OLED_DIS_BLACK:
            printk( KERN_INFO " mmi_dis_sta: OLED_DIS_BLACK!!!\r\n " );						
            pr_ret = (int)balong_tft_ioctl(NULL, (unsigned int)OLED_ALL_BLACK, 0);
            break;
        case OLED_DIS_WHITE:    
            printk( KERN_INFO " mmi_dis_sta: OLED_DIS_WHITE!!!\r\n " );						
            pr_ret = balong_tft_ioctl(NULL, (unsigned int)OLED_ALL_WHITE, 0);    

            break;
        case OLED_DIS_IMAGE:    
            printk( KERN_INFO " mmi_dis_sta: OLED_DIS_IMAGE!!!\r\n " );						

            pr_ret = balong_tft_ioctl(NULL, (unsigned int)OLED_ALL_BLACK, 0);    

/* BEIGN ,Added by xuchao,2012/2/21 */
#if ( FEATURE_E5 == FEATURE_ON ) && (defined(VERSION_V3R2))
            pr_ret = balong_tft_ioctl(NULL, (unsigned int)OLED_WRITE_IMAGE, (unsigned long)&mmi_image_dis); 
#endif

#if ((defined (CHIP_BB_6920ES) || defined (CHIP_BB_6920CS))\
			&& (defined (BOARD_ASIC)||defined (BOARD_ASIC_BIGPACK)))
#if defined(FEATURE_LCD_BOTTOM)				
            tftRefreshByBit(0,32,128,64,g_AllIconPic);
#else
			tftRefreshByBit(0,0,128,128,g_AllIconPic);
#endif

#endif /*((defined (CHIP_BB_6920ES)...*/
/* END	 ,Added by xuchao,2012/2/21 */

			break;
        default:    
            printk( KERN_INFO " mmi_dis_sta is %d !!!\r\n ", oled_dis_sta );
            break;						
    }

    /*呼吸灯测试: 点亮或者熄灭LED呼吸灯*/
#if (FEATURE_BREATH_LIGHT == FEATURE_ON)
    pr_ret = balong_breath_led_ioctl( 0, 0, (unsigned int)BREATH_LED_ID_POWER, (unsigned int)((oled_dis_sta+1)%2) );
#endif

    if ( pr_ret )
    {
        //for lint
    }
	
}

/******************************************************
  Function:  mmi_test_over
  Description: whether the mmi test complete or not?
  Input:  none
  output: true or false
  author: g175336
  date: 2012.01.06
******************************************************/
unsigned int mmi_test_over(void)
{
    if ( mmi_dis_sta < OLED_DIS_MAX )
    {
        return false;
    }
    else if ( 3 > mmi_test_event.pwr_key_cnt )
    {
        return false;
    }
    else if ( 3 > mmi_test_event.wps_key_cnt )
    {
        return false;
    }
    else if ( 3 > mmi_test_event.rst_key_cnt )
    {
        return false;
    }
    else
    {
        return true;
    }
}
/******************************************************
  Function:  exit_mmi_for_timeout
  Description: exit mmi test mode for key press or whole time out
  Input:  none
  output: none
  author: g175336
  date: 2012.01.06
*****************************************************/
void exit_mmi_for_timeout(void)
{
    int lint_ret = 0;  //for lint
    mmi_test_mode = false;   
    mmi_test_event.pwr_key_cnt =0;
    mmi_test_event.wps_key_cnt = 0;
    mmi_test_event.rst_key_cnt = 0;
    mmi_test_event.reserved=0;
    mmi_test_event.timeout = 0;

    mmi_write_nv_f();
    
    init_completion( &mmi_test_event.mmi_test_start );
    init_completion( &mmi_test_event.key_to_test );

    /*mmi测试超时:清空屏幕并且关闭电源指示灯*/
    lint_ret = balong_breath_led_ioctl( 0, 0, (unsigned int)BREATH_LED_ID_POWER, 0 );
    lint_ret = balong_tft_ioctl (NULL, (unsigned int)OLED_ALL_BLACK, 0);
    if ( lint_ret )
    {
      //for lint
    }
//    tftStringDisplay( 0, 0, "MMI TEST TIMEOUT" );

    /*屏幕显示"X"*/
    tftUpdateDisplay(false);
    mdelay( 3000 );  			
}
/******************************************************
  Function:  mmi_nv_iden
  Description: identify mmi nv 
  Input:  none
  output: true: mmi nv has not been writen and it's factory verion 
             false: mmi nv has been writen or not factory verion 
  author: g175336
  date: 2012.01.29
*****************************************************/
int mmi_nv_iden(void)
{
    int ret = false;
    unsigned int ulSwVerFlag = 0xFFFFFFFF;
    char aucFactoryInfo[NV_FACTORY_INFO_I_SIZE] = {0};
    printk( KERN_INFO "%s: Enter!!!", __func__ );	
	
    while ( NULL == g_stMspRegFunc.OM_read_nv || NULL == g_stMspRegFunc.OM_write_nv  )
    {
        printk( KERN_INFO " Kernel NV read and write function have NOT been configured!!! " );
        msleep(5000);

#if ((defined (CHIP_BB_6920ES) || defined (CHIP_BB_6920CS))\
    && (defined (BOARD_ASIC)||defined (BOARD_ASIC_BIGPACK))) \
    && !defined(PRODUCT_CFG_BUILD_SEPARATE)
		g_stMspRegFunc.OM_read_nv = &NVM_Read;
		g_stMspRegFunc.OM_write_nv = &NVM_Write;
#endif

    }
    printk( KERN_INFO " Kernel NV read and write function have been configured!!! " );    

    /*读NV项,判断是否是产线版本*/
/* BEIGN ,Added by xuchao,2012/3/1 */	
    ret = ( *g_stMspRegFunc.OM_read_nv )( en_NV_Item_SW_VERSION_FLAG, &ulSwVerFlag, sizeof( ulSwVerFlag ) );

#if ((defined (CHIP_BB_6920ES) || defined (CHIP_BB_6920CS))\
&& (defined (BOARD_ASIC)||defined (BOARD_ASIC_BIGPACK)))
	while ( ret  ==  ERR_MSP_NO_INITILIZATION || ret == 520 )//520表示NV不存在的情况
    {
        printk( KERN_INFO " ulSwVerFlag is %d,ret=%d\r\n ", ulSwVerFlag ,ret);
        msleep(5000);
		ret = ( *g_stMspRegFunc.OM_read_nv )( en_NV_Item_SW_VERSION_FLAG, &ulSwVerFlag, sizeof( ulSwVerFlag ) );
    }
#endif /*((defined (CHIP_BB_6920ES)...*/

    printk( KERN_INFO " ulSwVerFlag is %d,ret=%d\r\n ", ulSwVerFlag ,ret);
/* END   ,Added by xuchao,2012/3/1 */
	
    if ( 0 == ulSwVerFlag ) 
    {

#if ((defined(CHIP_BB_6920ES) || defined (CHIP_BB_6920CS)) && (FEATURE_E5 == FEATURE_ON))
        is_current_firmware_factory = !ulSwVerFlag;
#endif /*(defined(CHIP_BB_6920...*/
        return true;
    }
    else
    {
        /*非产线版本: 返回false*/
        return false;   
    }

}

/******************************************************
  Function:  mmi_write_nv
  Description: write NV when the mmi test complete
  Input:  none
  output: none
  author: g175336
  date: 2012.01.06
*****************************************************/
void mmi_write_nv(void)
{
    char aucFactoryInfo[NV_FACTORY_INFO_I_SIZE] = {0};
    printk( KERN_INFO "%s: Enter!!!\r\n", __func__ );	

    /*判断OM是否已经注册过NV读写的函数*/
    if ( NULL == g_stMspRegFunc.OM_read_nv || NULL == g_stMspRegFunc.OM_write_nv  )
    {
        printk( KERN_ERR " Kernel NV read and write function have NOT been configured!!! " );
    }
    else
    {
        /*先读NV项*/
        printk( KERN_INFO " Kernel NV read and write function have been configured!!! " );    
        ( *g_stMspRegFunc.OM_read_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );
        printk( KERN_INFO " 000aucFactoryInfo is %s\r\n ", &aucFactoryInfo[MMI_TEST_FLAG_OFFSET] );
		
        /*将MMI测试成功标志写入NV*/    	
        memcpy( &aucFactoryInfo[MMI_TEST_FLAG_OFFSET], MMI_TEST_FLAG_SUCCESS, strlen(MMI_TEST_FLAG_SUCCESS) );	     
        ( *g_stMspRegFunc.OM_write_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );    

        /*再读NV项*/
        ( *g_stMspRegFunc.OM_read_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );
        printk( KERN_INFO " 111aucFactoryInfo is %s\r\n ", &aucFactoryInfo[MMI_TEST_FLAG_OFFSET] );

    }		
}

//for ecall test begin
void mmi_write_ver( unsigned int flag )
{
    unsigned int ulSwVerFlag = 0xff;
    printk( KERN_INFO "%s: flag: %d\r\n", __func__, flag );	

    /*判断OM是否已经注册过NV读写的函数*/
    if ( NULL == g_stMspRegFunc.OM_read_nv || NULL == g_stMspRegFunc.OM_write_nv  )
    {
        printk( KERN_ERR " Kernel NV read and write function have NOT been configured!!! " );
    }
    else
    {
        printk( KERN_INFO " Kernel NV read and write function have been configured!!! " );    

        /*读NV项,判断是否是产线版本*/
        ( *g_stMspRegFunc.OM_read_nv )( en_NV_Item_SW_VERSION_FLAG, &ulSwVerFlag, sizeof( ulSwVerFlag ) );
        printk( KERN_INFO " ulSwVerFlag is %d\r\n ", ulSwVerFlag );
  
        /*写NV产线版本*/
        ( *g_stMspRegFunc.OM_write_nv )( en_NV_Item_SW_VERSION_FLAG, &flag, sizeof( flag ) );

        /*读NV项,判断是否是产线版本*/
        ( *g_stMspRegFunc.OM_read_nv )( en_NV_Item_SW_VERSION_FLAG, &ulSwVerFlag, sizeof( ulSwVerFlag ) );
        printk( KERN_INFO " ulSwVerFlag is %d\r\n ", ulSwVerFlag );
    }		
}

void mmi_clear_nv(void)
{
    char aucFactoryInfo[NV_FACTORY_INFO_I_SIZE] = {0};
    printk( KERN_INFO "%s: Enter!!!\r\n", __func__ );	

    /*判断OM是否已经注册过NV读写的函数*/
    if ( NULL == g_stMspRegFunc.OM_read_nv || NULL == g_stMspRegFunc.OM_write_nv  )
    {
        printk( KERN_ERR " Kernel NV read and write function have NOT been configured!!! " );
    }
    else
    {
        printk( KERN_INFO " Kernel NV read and write function have been configured!!! " );    
        ( *g_stMspRegFunc.OM_read_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );
        printk( KERN_INFO " 000aucFactoryInfo is %s\r\n ", &aucFactoryInfo[MMI_TEST_FLAG_OFFSET] );
		
        /*将MMI测试标志清除*/    	
        memset( &aucFactoryInfo[MMI_TEST_FLAG_OFFSET], 0, strlen(MMI_TEST_FLAG_SUCCESS) );	     
        ( *g_stMspRegFunc.OM_write_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );    

        /*读NV项*/
        ( *g_stMspRegFunc.OM_read_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );
        printk( KERN_INFO " 111aucFactoryInfo is %s\r\n ", &aucFactoryInfo[MMI_TEST_FLAG_OFFSET] );

    }		
}

void mmi_write_nv_f(void)
{
    char aucFactoryInfo[NV_FACTORY_INFO_I_SIZE] = {0};
    printk( KERN_INFO "%s: Enter!!!\r\n", __func__ );	

    /*判断OM是否已经注册过NV读写的函数*/
    if ( NULL == g_stMspRegFunc.OM_read_nv || NULL == g_stMspRegFunc.OM_write_nv  )
    {
        printk( KERN_ERR " Kernel NV read and write function have NOT been configured!!! " );
    }
    else
    {
        /* 先读NV项 */
        printk( KERN_INFO " Kernel NV read and write function have been configured!!! " );    
        ( *g_stMspRegFunc.OM_read_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );
        printk( KERN_INFO " 000aucFactoryInfo is %s\r\n ", &aucFactoryInfo[MMI_TEST_FLAG_OFFSET] );
		
        /*将MMI测试失败标志写入NV*/    	
        memcpy( &aucFactoryInfo[MMI_TEST_FLAG_OFFSET], MMI_TEST_FLAG_FAILED, strlen(MMI_TEST_FLAG_FAILED) );	     
        ( *g_stMspRegFunc.OM_write_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );    

        /*再读NV项*/
        ( *g_stMspRegFunc.OM_read_nv )( NV_FACTORY_INFO_I, (void *)aucFactoryInfo, NV_FACTORY_INFO_I_SIZE );
        printk( KERN_INFO " 111aucFactoryInfo is %s\r\n ", &aucFactoryInfo[MMI_TEST_FLAG_OFFSET] );

    }		
}
//for ecall test end

/******************************************************
  Function:  mmi_test_success
  Description: mmi test complete
  Input:  none
  output: none
  author: g175336
  date: 2012.01.06
*****************************************************/
void mmi_test_success()
{
    int lint_ret = 0;	
    mmi_write_nv();
 
    /* 在屏幕上显示"MMI TEST SUCCESS!", 后面会改成"V" 图标*/
    lint_ret = balong_tft_ioctl( NULL, (int)OLED_ALL_BLACK, 0 );  
//    mdelay( 100 );	
    //tftStringDisplay( 0, 0, MMI_TEST_SUCCESS );

    /*屏幕显示"V"*/
    tftUpdateDisplay(true);
    mdelay( 3000 );	

    /*mmi测试完成后重启*/	
    //usrPlatformReset();
    //wdtReboot();
    //if ( lint_ret )
    //{
      //for lint
    //}
}

static void balong_mmi_thread(void)
{
    int ret = false;
	MMI_USIM_STA MMI_USIMSTA_RET  = MMI_USIM_NOT_EXIST;
	MMI_FILE_STA MMI_FILE_STA_RET = MMI_SD_NOT_INIT;
#if((FEATURE_ON == FEATURE_E5371_MMI))
    MMI_ADC_STA MMI_ADC_STA_RET = MMI_ADC_TEMP_MAX;
    unsigned short ucHwVer = 0;
    ucHwVer = BSP_HwGetVerMain();    /* 获取硬件版本号 */
#endif

    /* V7R1单编版本不起MMI */
#if (defined (CHIP_BB_6920ES) || defined (CHIP_BB_6920CS))
    #if(defined (BOARD_ASIC)||defined (BOARD_ASIC_BIGPACK)) \
        && !defined(PRODUCT_CFG_BUILD_SEPARATE)
    if ( false == mmi_nv_iden() )
    {
        printk( KERN_ERR " %s: NOT factory version or MMI test repeat!!!\r\n ", __func__ );
        return;
    }
    #else
    return;
    #endif
#else
    if ( false == mmi_nv_iden() )
    {
        printk( KERN_ERR " %s: NOT factory version or MMI test repeat!!!\r\n ", __func__ );
        return;    
    }
#endif

    while(1)
    {
        if ( false == mmi_test_mode )  
        {	
            printk( KERN_INFO " %s: waiting for mmi start!!!!\r\n ", __func__ );
#ifdef FEATURE_SD_ENABLE
            /*有SD卡的产品需要检测SD卡中的文件是否存在*/
			MMI_FILE_STA_RET = mmi_file_exist();
#else
            /*屏幕上给予工人可以进入MMI的提示,以便让工人知道什么时候开机点击按键进入*/
			balong_tft_ioctl (NULL, (unsigned int)OLED_ALL_BLACK, 0);
			tftStringDisplay( 12, 58, (UINT8 *)MMI_TEST_READY );

			/*没有SD卡的产品需要等power键双击后才能进入*/
            wait_for_completion( &mmi_test_event.mmi_test_start );
            MMI_FILE_STA_RET = MMI_FILE_OK;
            /*进入后，先清理NV*/
            mmi_clear_nv();
#endif

#if (FEATURE_OTG == FEATURE_ON)            
            if ( ( ( MMI_FILE_OK == MMI_FILE_STA_RET ) \
                && ( false == mmi_test_event.key_timeout ) ) \
                || ( 0x55 == no_card_debug_mode ) ) 
#else
            if ( ( MMI_FILE_OK == MMI_FILE_STA_RET ) && ( false == mmi_test_event.key_timeout ) ) 
#endif
            {
       			/*SIM卡状态判断，如不在位则直接退出MMI*/
				MMI_USIMSTA_RET = mmi_usim_exist();
       			if( MMI_USIM_EXIST== MMI_USIMSTA_RET )
       			{
       				balong_tft_ioctl (NULL, (unsigned int)OLED_ALL_BLACK, 0);
       				tftStringDisplay( 32, 58, (UINT8 *)USIM_TEST_PASS );
       				msleep(3000);
       			}
       			else
       			{
       			    balong_tft_ioctl (NULL, (unsigned int)OLED_ALL_BLACK, 0);
       				tftStringDisplay( 32, 58, (UINT8 *)USIM_TEST_FAIL );
       				msleep(3000);
					exit_mmi_for_timeout();
       				return;
   				}
            #if (FEATURE_OTG == FEATURE_ON)
                ret = BSP_GetExtChgSta();

                if (( true == ret )\ 
                    || (1 == no_AF10_debug_mode)) //模拟对外充电成功

                {

                    tftClearWholeScreen();
                    tftStringDisplay(32,58, (unsigned char *)"Charge Pass!!");
                    msleep(3000);

                }
                else //模拟对外充电失败
                {

                    tftClearWholeScreen();
                    tftStringDisplay(32,58, (unsigned char *)"Charge Fail!!");
                    msleep(3000);
                    exit_mmi_for_timeout();
                    return;

                }
            #endif
                enter_mmi_test();
            }
            else 
            {
                msleep(3000);
            }
        }
        else 
        {
            /*等待按键按下*/	
            ret = wait_for_completion_timeout( &mmi_test_event.key_to_test, mmi_test_event.timeout - jiffies );

            /* mmi测试超时(5 min)或者按键按下时间超时(5S), 返回正常模式 */ 
            if ( ( 0 == ret ) || ( true == mmi_test_event.key_timeout ) )		
            {
                printk( KERN_INFO "Exit mmi test mode for: ret=%d, key_timeout=%d...\r\n", \
                    ret, mmi_test_event.key_timeout );
                exit_mmi_for_timeout();  
            }
            else  
            {  
                mmi_dis_roll( mmi_dis_sta++ );
				
                /*判断mmi测试是否结束*/
                if ( mmi_test_over() ) 
                {
                    msleep(3000);
                    if ( true == mmi_test_event.key_timeout )
                    {
                        exit_mmi_for_timeout();  
                    }
                    else
                    {
                        printk( KERN_INFO " MMI test success!!!\r\n " );
                        mmi_test_success();
                    }
                }
				else
				{
				    continue;
				}
                   				
            }
			return;
        }
    		
    }
}

void __init balong_mmi_init(void)
{
    struct task_struct *tsk;

    printk( KERN_INFO " %s: begin!!! \r\n", __func__ );
    init_completion( &mmi_test_event.mmi_test_start );
    init_completion( &mmi_test_event.key_to_test );
	
	mmi_sci_ifc_init();
#if((FEATURE_ON == FEATURE_E5371_MMI))
    mmi_adc_ifc_init();
#endif

    /* 创建MMI测试线程(仅限于产线版本) */
    tsk = kthread_run(balong_mmi_thread, NULL, "MMI-test");
    if (!IS_ERR(tsk))
    {		
        printk( KERN_ERR " %s: Thread create error!!!\r\n ", __func__ );
        return;
    }
    printk( KERN_INFO " %s: end!!! \r\n", __func__ );
}

late_initcall(balong_mmi_init);
#endif

